import { logger } from '../utils/logger';
import { generateGeminiStream } from './geminiService';
import { intelligentCacheSystem } from './intelligentCacheSystem';
import { smartRecommendationEngine } from './smartRecommendationEngine';

interface VoiceConfig {
  language: string;
  accent: string;
  speed: number;
  pitch: number;
  voice: 'male' | 'female' | 'neutral';
}

interface VoiceInteraction {
  id: string;
  userId?: string;
  sessionId: string;
  audioInput?: Blob;
  transcription: string;
  aiResponse: string;
  audioOutput?: Blob;
  timestamp: number;
  duration: number;
  confidence: number;
  conversationContext: string[];
}

interface VoiceAnalytics {
  totalInteractions: number;
  avgConfidence: number;
  avgDuration: number;
  preferredVoice: string;
  topCommands: Array<{ command: string; count: number }>;
  errorRate: number;
}

class VoiceAI {
  private recognition: SpeechRecognition | null = null;
  private synthesis: SpeechSynthesis;
  private isListening = false;
  private voiceInteractions = new Map<string, VoiceInteraction[]>();
  private userVoicePreferences = new Map<string, VoiceConfig>();
  private analytics: VoiceAnalytics = {
    totalInteractions: 0,
    avgConfidence: 0,
    avgDuration: 0,
    preferredVoice: 'female',
    topCommands: [],
    errorRate: 0
  };

  constructor() {
    this.synthesis = window.speechSynthesis;
    this.initializeSpeechRecognition();
    this.setupVoiceCommands();
  }

  // Speech Recognition ba≈ülat
  private initializeSpeechRecognition(): void {
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();
      
      this.recognition.continuous = false;
      this.recognition.interimResults = false;
      this.recognition.lang = 'tr-TR';
      this.recognition.maxAlternatives = 3;
      
      logger.log('üéôÔ∏è Speech Recognition initialized');
    } else {
      logger.warn('‚ùå Speech Recognition not supported');
    }
  }

  // Ses komutlarƒ±nƒ± ayarla
  private setupVoiceCommands(): void {
    const commands = {
      'paket √∂ner': this.handlePackageRequest.bind(this),
      'rezervasyon yap': this.handleBookingRequest.bind(this),
      'fiyat sor': this.handlePriceInquiry.bind(this),
      'yardƒ±m': this.handleHelpRequest.bind(this),
      'sesli aramayƒ± durdur': this.stopListening.bind(this)
    };
    
    logger.log('üéôÔ∏è Voice commands configured:', Object.keys(commands));
  }

  // Dinlemeye ba≈üla
  async startListening(userId?: string, sessionId?: string): Promise<VoiceInteraction | null> {
    if (!this.recognition) {
      throw new Error('Speech Recognition not supported');
    }

    if (this.isListening) {
      logger.warn('üéôÔ∏è Already listening');
      return null;
    }

    return new Promise((resolve, reject) => {
      if (!this.recognition) {
        reject(new Error('Speech Recognition not available'));
        return;
      }

      const startTime = Date.now();
      this.isListening = true;
      
      // User voice preferences'ƒ± al
      const voiceConfig = userId ? this.userVoicePreferences.get(userId) : null;
      if (voiceConfig) {
        this.recognition.lang = voiceConfig.language === 'en' ? 'en-US' : 'tr-TR';
      }

      this.recognition.onstart = () => {
        logger.log('üéôÔ∏è Voice recording started');
      };

      this.recognition.onresult = async (event) => {
        const transcript = event.results[0][0].transcript;
        const confidence = event.results[0][0].confidence;
        const duration = Date.now() - startTime;

        logger.log(`üéôÔ∏è Voice recognized: "${transcript}" (confidence: ${confidence.toFixed(2)})`);

        // Interaction olu≈ütur
        const interaction: VoiceInteraction = {
          id: `voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          userId,
          sessionId: sessionId || 'voice_session',
          transcription: transcript,
          aiResponse: '',
          timestamp: Date.now(),
          duration,
          confidence,
          conversationContext: []
        };

        try {
          // AI yanƒ±tƒ± olu≈ütur
          const aiResponse = await this.generateVoiceResponse(transcript, userId, sessionId);
          interaction.aiResponse = aiResponse;

          // Sesli yanƒ±t olu≈ütur
          await this.speakResponse(aiResponse, userId);

          // Interaction'ƒ± kaydet
          this.saveVoiceInteraction(userId || 'anonymous', interaction);

          // Analytics g√ºncelle
          this.updateAnalytics(interaction);

          resolve(interaction);
        } catch (error) {
          logger.error('‚ùå Voice AI error:', error);
          reject(error);
        }

        this.isListening = false;
      };

      this.recognition.onerror = (event) => {
        logger.error('‚ùå Speech recognition error:', event.error);
        this.isListening = false;
        this.analytics.errorRate = (this.analytics.errorRate + 1) / (this.analytics.totalInteractions + 1);
        reject(new Error(`Speech recognition error: ${event.error}`));
      };

      this.recognition.onend = () => {
        logger.log('üéôÔ∏è Voice recording ended');
        this.isListening = false;
      };

      this.recognition.start();
    });
  }

  // Dinlemeyi durdur
  stopListening(): void {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
      this.isListening = false;
      logger.log('üéôÔ∏è Voice listening stopped');
    }
  }

  // Voice response olu≈ütur
  private async generateVoiceResponse(transcript: string, userId?: string, sessionId?: string): Promise<string> {
    logger.log('ü§ñ Generating voice response for:', transcript);

    // √ñzel ses komutlarƒ±nƒ± kontrol et
    const specialResponse = this.handleSpecialVoiceCommands(transcript, userId);
    if (specialResponse) {
      return specialResponse;
    }

    // AI response olu≈ütur (message format'a √ßevir)
    const messages = [
      {
        role: 'user' as const,
        content: transcript,
        timestamp: new Date().toISOString(),
        sessionId: sessionId || 'voice_session',
        userId: userId || null
      }
    ];

    try {
      // Gemini'den yanƒ±t al
      const responseGenerator = generateGeminiStream(messages, sessionId, userId, 'voice-optimized');
      let fullResponse = '';
      
      for await (const chunk of responseGenerator) {
        fullResponse += chunk;
      }

      // Voice i√ßin optimize et
      return this.optimizeForVoice(fullResponse, userId);
    } catch (error) {
      logger.error('‚ùå Voice response generation failed:', error);
      return this.getFallbackVoiceResponse(transcript, userId);
    }
  }

  // Sesli yanƒ±t i√ßin optimize et
  private optimizeForVoice(response: string, userId?: string): string {
    // User voice preferences al
    const voiceConfig = userId ? this.userVoicePreferences.get(userId) : null;
    
    let optimizedResponse = response
      // Markdown formatting'i temizle
      .replace(/\*\*(.*?)\*\*/g, '$1')
      .replace(/\*(.*?)\*/g, '$1')
      .replace(/`(.*?)`/g, '$1')
      .replace(/#{1,6}\s/g, '')
      
      // SHOW_PACKAGES komutlarƒ±nƒ± sesli a√ßƒ±klamalara √ßevir
      .replace(/\*\*SHOW_PACKAGES:(\w+)\*\*/g, (match, category) => {
        return `Size ${category} kategorisinde harika paketler g√∂sterebilirim.`;
      })
      
      // Emoji'leri sesli a√ßƒ±klamalara √ßevir
      .replace(/‚ú®/g, '√∂zel')
      .replace(/üíï/g, 'sevgiyle')
      .replace(/üèùÔ∏è/g, 'ada tatili')
      .replace(/üíé/g, 'l√ºks')
      .replace(/‚≠ê/g, 'yƒ±ldƒ±zlƒ±')
      
      // URL'leri temizle
      .replace(/https?:\/\/[^\s]+/g, 'websitemizde detaylarƒ± g√∂rebilirsiniz')
      
      // Uzun c√ºmleleri b√∂l
      .replace(/[.!?]\s*(?=[A-Z√áƒûI√ñ≈û√úa-z√ßƒüƒ±√∂≈ü√º])/g, '$& '); // Noktalama sonrasƒ± pause

    // Sesli yanƒ±t i√ßin daha kƒ±sa tut
    if (optimizedResponse.length > 300) {
      const sentences = optimizedResponse.split(/[.!?]+/);
      optimizedResponse = sentences.slice(0, 3).join('. ') + '.';
    }

    // Ki≈üiselle≈ütirme
    if (voiceConfig?.voice === 'formal') {
      optimizedResponse = optimizedResponse.replace(/merhaba/gi, 'ƒ∞yi g√ºnler');
    }

    return optimizedResponse.trim();
  }

  // √ñzel ses komutlarƒ±nƒ± i≈üle
  private handleSpecialVoiceCommands(transcript: string, userId?: string): string | null {
    const lowerTranscript = transcript.toLowerCase();

    if (lowerTranscript.includes('paket √∂ner') || lowerTranscript.includes('paket √∂nerir')) {
      return this.handlePackageRequest(transcript, userId);
    }

    if (lowerTranscript.includes('rezervasyon') || lowerTranscript.includes('ayƒ±rt')) {
      return this.handleBookingRequest(transcript, userId);
    }

    if (lowerTranscript.includes('fiyat') || lowerTranscript.includes('ne kadar')) {
      return this.handlePriceInquiry(transcript, userId);
    }

    if (lowerTranscript.includes('yardƒ±m') || lowerTranscript.includes('nasƒ±l')) {
      return this.handleHelpRequest(transcript, userId);
    }

    return null;
  }

  // Paket √∂nerisi i≈üle
  private handlePackageRequest(transcript: string, userId?: string): string {
    if (userId) {
      try {
        const recommendations = smartRecommendationEngine.generateSmartRecommendations(
          userId,
          transcript,
          { conversationPhase: 'voice_discovery', urgencyLevel: 'medium' }
        );

        if (recommendations.packages.length > 0) {
          const topPackage = recommendations.packages[0];
          return `Size √∂zel olarak ${topPackage.packageId} paketini √∂neriyorum. ${topPackage.reasons.slice(0, 2).join(' ve ')} nedeniyle size √ßok uygun. Detaylarƒ±nƒ± g√∂rmek ister misiniz?`;
        }
      } catch (error) {
        logger.error('‚ùå Voice package recommendation failed:', error);
      }
    }

    return "Size harika balayƒ± paketlerimizi √∂nerebilirim. Hangi destinasyonu tercih edersiniz? Bali, Paris veya Santorini gibi pop√ºler se√ßeneklerimiz var.";
  }

  // Rezervasyon i≈üle
  private handleBookingRequest(transcript: string, userId?: string): string {
    return "Rezervasyon yapmak i√ßin size yardƒ±mcƒ± olabilirim. Hangi paketi tercih ediyorsunuz? Size √∂zel fiyat teklifim var.";
  }

  // Fiyat sorgusunu i≈üle
  private handlePriceInquiry(transcript: string, userId?: string): string {
    return "Paket fiyatlarƒ±mƒ±z 2800 dolardan ba≈ülayƒ±p 4800 dolara kadar √ßƒ±kƒ±yor. B√ºt√ßenizi s√∂ylerseniz size en uygun se√ßenekleri √∂nerebilirim.";
  }

  // Yardƒ±m i≈üle
  private handleHelpRequest(transcript: string, userId?: string): string {
    return "Size nasƒ±l yardƒ±mcƒ± olabilirim? Paket √∂nerileri, rezervasyon yapma, fiyat bilgisi veya destinasyon hakkƒ±nda sorularƒ±nƒ±zƒ± yanƒ±tlayabilirim. Ne istiyorsunuz?";
  }

  // Fallback yanƒ±t
  private getFallbackVoiceResponse(transcript: string, userId?: string): string {
    const fallbacks = [
      "Anlamadƒ±m, tekrar s√∂yleyebilir misiniz?",
      "Size nasƒ±l yardƒ±mcƒ± olabilirim?",
      "Balayƒ± planlamanƒ±zda size yardƒ±mcƒ± olmaya hazƒ±rƒ±m. Ne istiyorsunuz?",
      "Daha net konu≈üabilir misiniz? Size yardƒ±mcƒ± olmak istiyorum."
    ];

    return fallbacks[Math.floor(Math.random() * fallbacks.length)];
  }

  // Sesli yanƒ±t olu≈ütur ve √ßal
  async speakResponse(text: string, userId?: string): Promise<void> {
    if (!this.synthesis) {
      logger.warn('‚ùå Speech Synthesis not supported');
      return;
    }

    // User voice preferences al
    const voiceConfig = userId ? this.userVoicePreferences.get(userId) : null;

    return new Promise((resolve, reject) => {
      // Mevcut konu≈ümalarƒ± durdur
      this.synthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      
      // Voice configuration
      if (voiceConfig) {
        utterance.lang = voiceConfig.language === 'en' ? 'en-US' : 'tr-TR';
        utterance.rate = voiceConfig.speed;
        utterance.pitch = voiceConfig.pitch;
      } else {
        utterance.lang = 'tr-TR';
        utterance.rate = 0.9; // Biraz yava≈ü konu≈ü
        utterance.pitch = 1.0;
      }

      // Mevcut sesleri kontrol et ve uygun olanƒ± se√ß
      const voices = this.synthesis.getVoices();
      const turkishVoices = voices.filter(voice => voice.lang.includes('tr'));
      
      if (turkishVoices.length > 0) {
        utterance.voice = turkishVoices[0];
      }

      utterance.onstart = () => {
        logger.log('üîä Speech synthesis started');
      };

      utterance.onend = () => {
        logger.log('üîä Speech synthesis completed');
        resolve();
      };

      utterance.onerror = (event) => {
        logger.error('‚ùå Speech synthesis error:', event.error);
        reject(new Error(`Speech synthesis error: ${event.error}`));
      };

      this.synthesis.speak(utterance);
    });
  }

  // Kullanƒ±cƒ± ses tercihlerini g√ºncelle
  updateUserVoicePreferences(userId: string, config: Partial<VoiceConfig>): void {
    const currentConfig = this.userVoicePreferences.get(userId) || {
      language: 'tr',
      accent: 'standard',
      speed: 0.9,
      pitch: 1.0,
      voice: 'female'
    };

    const updatedConfig = { ...currentConfig, ...config };
    this.userVoicePreferences.set(userId, updatedConfig);
    
    logger.log(`üéôÔ∏è Voice preferences updated for user ${userId}:`, updatedConfig);
  }

  // Voice interaction kaydet
  private saveVoiceInteraction(userId: string, interaction: VoiceInteraction): void {
    const interactions = this.voiceInteractions.get(userId) || [];
    interactions.push(interaction);
    
    // Son 50 interaction'ƒ± tut
    if (interactions.length > 50) {
      interactions.shift();
    }
    
    this.voiceInteractions.set(userId, interactions);
    
    // Intelligent cache'e ekle
    intelligentCacheSystem.addSmartCache(
      interaction.transcription,
      interaction.aiResponse,
      userId,
      'tr',
      interaction.duration,
      ['voice-interaction', `confidence-${Math.round(interaction.confidence * 10)}`]
    );
  }

  // Analytics g√ºncelle
  private updateAnalytics(interaction: VoiceInteraction): void {
    this.analytics.totalInteractions++;
    
    // Running averages
    const count = this.analytics.totalInteractions;
    this.analytics.avgConfidence = ((this.analytics.avgConfidence * (count - 1)) + interaction.confidence) / count;
    this.analytics.avgDuration = ((this.analytics.avgDuration * (count - 1)) + interaction.duration) / count;

    // Top commands
    const command = this.extractCommand(interaction.transcription);
    if (command) {
      const existingCommand = this.analytics.topCommands.find(c => c.command === command);
      if (existingCommand) {
        existingCommand.count++;
      } else {
        this.analytics.topCommands.push({ command, count: 1 });
      }
      
      // Sort by count and keep top 10
      this.analytics.topCommands.sort((a, b) => b.count - a.count);
      this.analytics.topCommands = this.analytics.topCommands.slice(0, 10);
    }
  }

  // Komut √ßƒ±kar
  private extractCommand(transcript: string): string | null {
    const lowerTranscript = transcript.toLowerCase();
    
    if (lowerTranscript.includes('paket')) return 'paket-√∂nerisi';
    if (lowerTranscript.includes('rezervasyon')) return 'rezervasyon';
    if (lowerTranscript.includes('fiyat')) return 'fiyat-sorgusu';
    if (lowerTranscript.includes('yardƒ±m')) return 'yardƒ±m';
    if (lowerTranscript.includes('merhaba')) return 'selamlama';
    
    return null;
  }

  // Public getters
  isCurrentlyListening(): boolean {
    return this.isListening;
  }

  getVoiceAnalytics(): VoiceAnalytics {
    return { ...this.analytics };
  }

  getUserVoiceHistory(userId: string): VoiceInteraction[] {
    return this.voiceInteractions.get(userId) || [];
  }

  getUserVoicePreferences(userId: string): VoiceConfig | null {
    return this.userVoicePreferences.get(userId) || null;
  }

  // Voice capability check
  static checkVoiceSupport(): {
    speechRecognition: boolean;
    speechSynthesis: boolean;
    voiceList: string[];
  } {
    const speechRecognition = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
    const speechSynthesis = 'speechSynthesis' in window;
    
    let voiceList: string[] = [];
    if (speechSynthesis && window.speechSynthesis) {
      voiceList = window.speechSynthesis.getVoices().map(voice => `${voice.name} (${voice.lang})`);
    }

    return {
      speechRecognition,
      speechSynthesis,
      voiceList
    };
  }

  // Cleanup
  destroy(): void {
    this.stopListening();
    if (this.synthesis) {
      this.synthesis.cancel();
    }
    this.voiceInteractions.clear();
    this.userVoicePreferences.clear();
    logger.log('üéôÔ∏è Voice AI destroyed');
  }
}

// Export singleton instance
export const voiceAI = new VoiceAI();
export default voiceAI;